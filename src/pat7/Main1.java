package pat7;

import java.util.Scanner;

/**
 * @author gljg
 *题意解析：根据指定的排列顺序，对所给的条带进行裁剪，求得按照排列顺序给出的最大条带的长度
 */
public class Main1 {

	static int[] state = new int[202]; //记录排列顺序
	static int[] dp = new int[202];   //记录最后所剪的条带
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n,m;
		//n用来接收颜色数目，但没什么用
		//m用来接收排列顺序的数字个数
		n = in.nextInt();
		m = in.nextInt();
		//i从1开始，循环累加到m个数字，此处重要的是state数组的特点
		//state数组是按照排列的数字作为下标，值为该数字在整个排列顺序中的位置
		//即通过条带的颜色（该颜色对应的数字）,去state数组中查询其值，查出来的是该颜色的条带在排列顺序中的位置
		//由于最后的结果是要求按照给定的排列顺序的最大长度，所以如果后面输入的state[y]的值<先前的state[x]的值，说明不是符合要求的排列顺序；
		//该条带应该剪去，这样就通过查询每个条带颜色的数字编号获取其顺序是否正确,达到了按排列顺序查找的要求
		for(int i=1;i<=m;++i){
			int x = in.nextInt();
			state[x] = i;
		}
		
		n = in.nextInt(); //n存放条带颜色的总个数
		//从0开始，遍历完条带的所有颜色
		for(int i=0;i<n;++i){   
			int x = in.nextInt();   //接收当前位置条带上的颜色编号
			//查询该条带的颜色在排列顺序中是否存在，对于那些在排列顺序中的条带的颜色编号，state[x]的值至少是从1开始编号，肯定>0;
			//如果此处state[x]的值==0,说明该条带的颜色不在排列顺序中，直接跳过，查询下一个条带的颜色
			if((x=state[x]) > 0){
				//如果能进来，说明该条带的颜色在排列顺序中存在，此时需要判断该颜色的值是否是上一个排序的颜色值之后
				//可以肯定的是，state存储的排列顺序越后的数字其值就越大
				//dp数组是用来存储条带最大长度的，所以对于存在一个颜色时，其长度为1，数组值只和条带的数目有关
				
				for(int y=x;y>=0;--y){
					//dp数组中的值默认都为0，当有条带数目进来时，此时应+1,dp[y]+1的目的就是为了将当前条带的数目算上去，
					//且y=x，--y,从当前条带开始判断，首先将自身加上去，再往前面判断，即--y,因为dp的下标存储的是排列顺序中的每个数字
					//对应的顺序值，假设下标为5，那么他前面的条带颜色的顺序依次为:4,3,2,1;不存在0（条带的编号从1开始）
					//所以符合题目的要求，指定颜色且指定排列顺序的最大的条带长度
					//由于是从最开始叠加的，所以y每次增大时都会加上顺序在它前面的数值，
					//又由于有的颜色可能在条带上不存在，dp中的值对应的下标可能并不是连续的，需要向前查询所有 的值
					dp[x] = dp[x]>=(dp[y]+1) ? dp[x] : (dp[y]+1);
				}
			}
		}
		
		//从dp数组中拿出最大的那个值，代表了按照要求排序后的最大的个数
		//n=0,dp[0]=1,是为了边界测试，即条带上一个颜色都没有的情况，但是牛客网上的测试用例没有显示该边界的例子
		n = 0;
		for(int i=0;i<=m;++i){
			n = n>=dp[i] ? n : dp[i];
		}
		System.out.println(n);
		
	}
	
}
